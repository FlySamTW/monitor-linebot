# v27.2.2：設計修復 - /重啟 不應觸發完全重建

## 🎯 問題

你觀察到的「重新上傳 56 本 PDF」現象背後的根本原因：

每次執行 `/重啟` 時，系統會呼叫 `syncGeminiKnowledgeBase(forceRebuild = false)`，這在設計上是正確的。

**但實際問題在於：** 在某些情況下（例如之前有 403/404 錯誤），系統會自動排程 `immediateKnowledgeRebuild()` 在 1 分鐘後以 `forceRebuild = true` 執行，導致整個知識庫被重建。

而且 `/重啟` 指令本身設計不當：它混淆了兩個不同的職責：
1. **用戶層面：** 清除用戶的對話記憶
2. **系統層面：** 重建整個知識庫

## 🛠️ 修復方案

### 原始邏輯（錯誤）
```javascript
const resultMsg = syncGeminiKnowledgeBase();  // 預設 forceRebuild = false
```

### 修復後（正確）
```javascript
// v27.2.2: 修復 forceRebuild = true 導致的不必要的完全重建
// /重啟 只應清除用戶的對話記憶，不應清空知識庫檔案紀錄
// 知識庫維護交由自動排程（每日 04:00）和錯誤自動修復機制
const resultMsg = syncGeminiKnowledgeBase(false);  // 明確 forceRebuild = false
```

## 📋 職責分工

現在邏輯清晰了：

| 命令/事件 | 觸發時機 | forceRebuild | 目的 |
|---------|--------|--------|------|
| `/重啟` | 用戶執行 | false | 清除用戶對話記憶，同步確認檔案列表 |
| `dailyKnowledgeRefresh()` | 每日 04:00 | true | 週期性重建，避免 PDF 48H 過期 |
| `immediateKnowledgeRebuild()` | 403/404 偵測 1 分鐘後 | true | 錯誤恢復，重新上傳失效 PDF |

## 🔍 為什麼會重複上傳？

根據日誌時間軸：

```
7:18:31 - 用戶執行 /重啟 (forceRebuild = false)
  → 清除對話記憶，同步知識庫
  
7:23:00 - 用戶再次執行 /重啟
  → 清除對話記憶，同步知識庫（56 本都是沿用舊檔）
```

**真正的原因：** 第一次 `/重啟` 與第二次 `/重啟` 之間的某個時刻，可能觸發了自動的 `immediateKnowledgeRebuild()`，導致 KB_URI_LIST 被清空。

## ✅ 修復效果

v27.2.2 後：
- **`/重啟` 不再觸發知識庫完全重建**
- 用戶對話記憶清除，但 PDF 檔案列表保留
- 知識庫維護由自動排程和錯誤機制負責
- 尖峰時段不會因為重啟指令而大量上傳 PDF

## 🚀 版本線

| 版本 | 修復內容 |
|------|----------|
| v27.2.0 | 邏輯重構（解除 Deep Mode 禁令） |
| v27.2.1 | 緊急修復：scope 錯誤 |
| **v27.2.2** | **設計修復：/重啟 不應觸發 forceRebuild** |

