/**
 * LINE Bot Assistant - å°ç£ä¸‰æ˜Ÿé›»è…¦è¢å¹•å°ˆå±¬å®¢æœ (Gemini 2.5 Flash)
 * Version: 21.66.0 (The True Expanded Version)
 * * * ç‰ˆæœ¬ä¿è­‰ï¼š
 * 1. [çµ•å°å±•é–‹] æ‰€æœ‰å‡½å¼èˆ‡é‚è¼¯åˆ¤æ–·å¼·åˆ¶å±•é–‹ (Block Style)ï¼Œæ‹’çµ•å–®è¡Œç¸®å¯«ï¼Œç¢ºä¿é‚è¼¯æ¸…æ™°ã€‚
 * 2. [ä¸Šä¸‹æ–‡å¢å¼·] getRelevantKBFiles è®€å–é›™æ–¹æœ€è¿‘ 6 å¥ï¼Œæ”¯æ´é€£çºŒè¿½å• (å¦‚ï¼šè«‹çµ¦æˆ‘æ›´å¤šç´°ç¯€)ã€‚
 * 3. [é€šç”¨æ˜ å°„] é€é CLASS_RULES è‡ªå‹•å»ºç«‹é—œéµå­—é—œè¯ (å¦‚ Odyssey3D -> G90XF)ã€‚
 * 4. [åŠŸèƒ½å®Œæ•´] Log å®Œæ•´ç´€éŒ„ã€LSéæ¿¾ã€æŒ‡ä»¤é–å®šã€Zero-Wait RAGã€‚
 */

// ==========================================
// 1. å…¨åŸŸé…ç½® (Global Configuration)
// ==========================================

const SHEET_NAMES = { 
  RECORDS: "æ‰€æœ‰ç´€éŒ„", 
  LOG: "LOG", 
  PROMPT: "Prompt", 
  LAST_CONVERSATION: "ä¸Šæ¬¡å°è©±", 
  QA: "QA",
  CLASS_RULES: "CLASS_RULES" 
};

const CACHE_KEYS = { 
  KB_URI_LIST: 'kb_list_v15_0', 
  KEYWORD_MAP: 'keyword_map_v1', 
  HISTORY_PREFIX: 'hist:', 
  ENTRY_DRAFT_PREFIX: 'entry_draft_', 
  PENDING_QUERY: 'pending_query_' 
};

const CONFIG = {
  MODEL_NAME: 'models/gemini-2.5-flash', 
  MAX_OUTPUT_TOKENS: 8192, 
  HISTORY_PAIR_LIMIT: 10, 
  CACHE_TTL_SEC: 3600,
  DRAFT_TTL_SEC: 300, 
  
  // ç®¡ç†å“¡èˆ‡ VIP è¨­å®š
  ADMIN_USER_ID: PropertiesService.getScriptProperties().getProperty('ADMIN_USER_ID') || '', 
  VIP_IMAGE_USER: PropertiesService.getScriptProperties().getProperty('VIP_USER_ID') || 'U3526e3a6c4ad0561f4c29584f90dfebe', 
  
  DRIVE_FOLDER_ID: PropertiesService.getScriptProperties().getProperty('DRIVE_FOLDER_ID') || '',
  API_ENDPOINT: 'https://generativelanguage.googleapis.com/v1beta'
};

// åˆå§‹åŒ– Spreadsheet
let ss = null;
try { 
  ss = SpreadsheetApp.getActiveSpreadsheet(); 
} catch (e) {
  const fallbackId = PropertiesService.getScriptProperties().getProperty('SPREADSHEET_ID');
  if (fallbackId) {
      try { 
          ss = SpreadsheetApp.openById(fallbackId); 
      } catch (e) {
          console.error("ç„¡æ³•é–‹å•Ÿè©¦ç®—è¡¨: " + e.message);
      }
  }
}

const ALLOW_PUSH = (PropertiesService.getScriptProperties().getProperty("ALLOW_PUSH") || "false") === "true";


// ==========================================
// 2. æ ¸å¿ƒï¼šGemini çŸ¥è­˜åº«åŒæ­¥ (Sync)
// ==========================================

function syncGeminiKnowledgeBase() {
  const lock = LockService.getScriptLock();
  try {
    // å˜—è©¦é–å®š 2 åˆ†é˜
    if (!lock.tryLock(120000)) {
        return "ç³»çµ±å¿™ç¢Œä¸­ï¼Œè«‹ç¨å¾Œå†è©¦";
    }

    writeLog(`[Sync] é–‹å§‹åŸ·è¡ŒçŸ¥è­˜åº«åŒæ­¥...`);
    
    const apiKey = PropertiesService.getScriptProperties().getProperty("GEMINI_API_KEY");
    if (!apiKey) {
        throw new Error("ç¼ºå°‘ GEMINI_API_KEY");
    }

    // è®€å–èˆŠçš„å¿«å–æ¸…å–®
    let oldKbList = [];
    const oldJson = PropertiesService.getScriptProperties().getProperty(CACHE_KEYS.KB_URI_LIST);
    if (oldJson) { 
        try { 
            oldKbList = JSON.parse(oldJson); 
        } catch(e) {
            writeLog("[Sync] èˆŠå¿«å–è§£æå¤±æ•—ï¼Œå°‡é‡å»º");
        } 
    }
    
    // å»ºç«‹æ¯”å° Map
    const existingFilesMap = new Map();
    oldKbList.forEach(item => { 
        if (item.name) {
            existingFilesMap.set(item.name, item.uri); 
        }
    });

    const newKbList = []; 
    let keywordMap = {};

    // --- A. Sheet è³‡æ–™è™•ç† (QAå„ªå…ˆ + è¦å‰‡åˆ†é›¢) ---
    
    // 1. QA å…§å®¹ (æœ€å„ªå…ˆ)
    let qaContent = "=== ğŸ’¡ ç²¾é¸å•ç­” (QA - æœ€å„ªå…ˆåƒè€ƒ) ===\n";
    const qaSheet = ss.getSheetByName(SHEET_NAMES.QA);
    if (qaSheet && qaSheet.getLastRow() > 1) {
      const data = qaSheet.getRange(2, 1, qaSheet.getLastRow() - 1, 1).getValues();
      const qaRows = data.map(row => {
          if (!row[0]) return "";
          return `QA: ${row[0]}`; 
      });
      qaContent += qaRows.join("\n\n");
    }

    // 2. CLASS_RULES (å®šç¾©èˆ‡è¦æ ¼åˆ†é›¢)
    let definitionsContent = "\n\n=== ğŸ“š é€šç”¨è¡“èªèˆ‡ç³»åˆ—å®šç¾© ===\n";
    let specsContent = "\n\n=== ğŸ“± è©³ç´°æ©Ÿå‹è¦æ ¼è³‡æ–™åº« (ç¡¬é«”åŠŸèƒ½ä»¥é€™è£¡ç‚ºæº–) ===\n";
    
    const ruleSheet = ss.getSheetByName(SHEET_NAMES.CLASS_RULES);
    if (ruleSheet && ruleSheet.getLastRow() > 1) {
      const data = ruleSheet.getRange(2, 1, ruleSheet.getLastRow() - 1, 1).getValues();
      
      data.forEach(row => {
          if (!row[0]) return;
          const text = row[0].toString();
          const parts = text.split(',');
          const key = parts[0] ? parts[0].trim().toUpperCase() : "";
          
          // åˆ†æµé‚è¼¯
          if (key.startsWith("LS")) {
              specsContent += `* ${text}\n`;
          } else {
              definitionsContent += `* ${text}\n`;
          }
          
          // å»ºç«‹å‹•æ…‹æ˜ å°„ (Map)
          if (key && text.length > key.length) {
              keywordMap[key] = text; 
          }
      });
    }
    
    // å„²å­˜æ˜ å°„è¡¨
    PropertiesService.getScriptProperties().setProperty(CACHE_KEYS.KEYWORD_MAP, JSON.stringify(keywordMap));
    writeLog(`[Sync] å»ºç«‹é—œéµå­—æ˜ å°„: ${Object.keys(keywordMap).length} ç­†`);
    
    // åˆä½µå…§å®¹
    const finalContent = `ã€ç¬¬ä¸€å„ªå…ˆè³‡æ–™åº«ã€‘\nè«‹çµ•å°å„ªå…ˆåƒè€ƒä»¥ä¸‹è³‡æ–™ã€‚\n${qaContent}\n${definitionsContent}\n${specsContent}`;
    
    // ä¸Šå‚³ Sheet å½™æ•´æ–‡å­—æª”
    const textBlob = Utilities.newBlob(finalContent, 'text/plain', 'samsung_kb_priority.txt');
    const textUri = uploadFileToGemini(apiKey, textBlob, textBlob.getBytes().length, 'text/plain');
    
    if (textUri) {
        newKbList.push({ name: 'samsung_kb_priority.txt', uri: textUri, mimeType: "text/plain", isPriority: true });
    } else {
        writeLog("[Sync] è­¦å‘Šï¼šSheet è³‡æ–™ä¸Šå‚³å¤±æ•—");
    }

    // --- B. Drive PDF åŒæ­¥ --- 
    let uploadCount = 0;
    let skipCount = 0;

    if (CONFIG.DRIVE_FOLDER_ID) {
      try {
        const folder = DriveApp.getFolderById(CONFIG.DRIVE_FOLDER_ID);
        const files = folder.getFilesByType(MimeType.PDF);

        while (files.hasNext()) {
          const file = files.next();
          const fileName = file.getName();
          const fileSize = file.getSize();
          
          // è·³ééå¤§æª”æ¡ˆ
          if (fileSize > 48 * 1024 * 1024) { 
            writeLog(`[Sync] âš ï¸ è·³ééå¤§æª”æ¡ˆ: ${fileName}`);
            continue;
          }

          if (existingFilesMap.has(fileName)) {
              newKbList.push({ name: fileName, uri: existingFilesMap.get(fileName), mimeType: "application/pdf" });
              skipCount++;
          } else {
              writeLog(`[Sync] æ­£åœ¨ä¸Šå‚³: ${fileName}`);
              const pdfUri = uploadFileToGemini(apiKey, file.getBlob(), fileSize, "application/pdf");
              
              if (pdfUri) {
                  newKbList.push({ name: fileName, uri: pdfUri, mimeType: "application/pdf" });
                  uploadCount++;
              } else {
                  writeLog(`[Sync] âŒ ä¸Šå‚³å¤±æ•—: ${fileName}`);
              }
          }
        }
      } catch (driveErr) {
        writeLog(`[Sync] âš ï¸ Drive è®€å–å¤±æ•—: ${driveErr.message}`);
      }
    }

    // æ›´æ–° Cache
    PropertiesService.getScriptProperties().setProperty(CACHE_KEYS.KB_URI_LIST, JSON.stringify(newKbList));
    
    const statusMsg = `âœ“ é‡å•Ÿèˆ‡åŒæ­¥å®Œæˆ\n- æ–°å¢ä¸Šå‚³ï¼š${uploadCount} æœ¬\n- æ²¿ç”¨èˆŠæª”ï¼š${skipCount} æœ¬\n- Sheet è³‡æ–™ï¼šå·²æ›´æ–°`;
    writeLog(statusMsg);
    
    // é ç´„ä¸‹æ¬¡åŒæ­¥
    scheduleNextSync();

    return statusMsg;

  } catch (e) {
    writeLog(`[Sync Error] ${e.message}`);
    return `ç³»çµ±éŒ¯èª¤: ${e.message}`;
  } finally {
    lock.releaseLock();
  }
}

// ä¸Šå‚³æª”æ¡ˆè‡³ Gemini
function uploadFileToGemini(apiKey, blob, fileSize, mimeType) {
  try {
    const initUrl = `https://generativelanguage.googleapis.com/upload/v1beta/files?key=${apiKey}`;
    const headers = {
      'X-Goog-Upload-Protocol': 'resumable',
      'X-Goog-Upload-Command': 'start',
      'X-Goog-Upload-Header-Content-Length': fileSize.toString(), 
      'X-Goog-Upload-Header-Content-Type': mimeType,
      'Content-Type': 'application/json'
    };
    const metadata = { file: { display_name: blob.getName() } };
    
    const initReq = UrlFetchApp.fetch(initUrl, { method: 'post', headers: headers, payload: JSON.stringify(metadata), muteHttpExceptions: true });
    
    if (initReq.getResponseCode() !== 200) {
        return null;
    }
    
    const uploadUrl = initReq.getHeaders()['x-goog-upload-url'];
    
    const uploadReq = UrlFetchApp.fetch(uploadUrl, {
      method: 'post',
      headers: { 'X-Goog-Upload-Offset': '0', 'X-Goog-Upload-Command': 'upload, finalize' },
      payload: blob, 
      muteHttpExceptions: true
    });
    
    if (uploadReq.getResponseCode() !== 200) {
        return null;
    }
    
    const fileRes = JSON.parse(uploadReq.getContentText());
    let state = fileRes.file.state;
    let attempts = 0;
    
    while (state === 'PROCESSING' && attempts < 30) {
      Utilities.sleep(1000);
      const check = UrlFetchApp.fetch(`${CONFIG.API_ENDPOINT}/${fileRes.file.name}?key=${apiKey}`);
      state = JSON.parse(check.getContentText()).state;
      attempts++;
    }
    
    if (state === 'ACTIVE') {
        return fileRes.file.uri;
    } else {
        return null;
    }

  } catch (e) {
    writeLog(`ä¸Šå‚³éŒ¯èª¤: ${e.message}`);
    return null;
  }
}

function scheduleNextSync() {
  try {
    const triggers = ScriptApp.getProjectTriggers();
    triggers.forEach(t => { 
        if (t.getHandlerFunction() === 'syncGeminiKnowledgeBase') {
            ScriptApp.deleteTrigger(t);
        }
    });
    ScriptApp.newTrigger('syncGeminiKnowledgeBase').timeBased().after(47 * 60 * 60 * 1000).create();
    writeLog("ğŸ•’ å·²é ç´„ 47 å°æ™‚å¾Œè‡ªå‹•æ›´æ–°çŸ¥è­˜åº«");
  } catch (e) { 
    writeLog(`âš ï¸ æ’ç¨‹è¨­å®šå¤±æ•—: ${e.message}`); 
  }
}


// ==========================================
// 3. Gemini API (é€šç”¨æ˜ å°„ + ä¸Šä¸‹æ–‡æ™ºæ…§æœå°‹)
// ==========================================

function getRelevantKBFiles(messages, kbList) {
    let combinedQuery = "";
    let userCount = 0;
    
    // 1. è®€å–ä¸Šä¸‹æ–‡ (User + AI, æœ€è¿‘ 6 å¥)
    for (let i = messages.length - 1; i >= 0; i--) {
        combinedQuery += " " + messages[i].content.toUpperCase();
        userCount++;
        if (userCount >= 6) break; 
    }

    // 2. è®€å–æ˜ å°„è¡¨
    let keywordMap = {};
    try {
        const mapJson = PropertiesService.getScriptProperties().getProperty(CACHE_KEYS.KEYWORD_MAP);
        if (mapJson) {
            keywordMap = JSON.parse(mapJson);
        }
    } catch(e) {}

    // 3. é—œéµå­—æ“´å…… (æŸ¥å­—å…¸)
    let extendedQuery = combinedQuery;
    Object.keys(keywordMap).forEach(key => {
        if (combinedQuery.includes(key)) {
            extendedQuery += " " + keywordMap[key].toUpperCase();
        }
    });

    // 4. æª”æ¡ˆæ¯”å°
    const relevantFiles = kbList.filter(file => {
        if (file.isPriority) return true; // Sheet æ°¸é ä¿ç•™
        
        const fileName = file.name.toUpperCase();
        // åŸºç¤é—œéµå­— (å‚™æ´)
        const baseKeywords = ["G9","G8","G7","G6","G5","G4","G3","M8","M7","M5","S9","S8","S6","ODYSSEY","SMART","VIEWFINITY","49","57","55","43","34","32","27","24","S49","S57","S55","S43","S34","S32","S27","S24","LS49","LS57","LS55","LS43","LS34","LS32","LS27","LS24"];
        
        // å‹•æ…‹åŒ¹é…: æª¢æŸ¥æ“´å……å¾Œçš„æŸ¥è©¢å­—ä¸²æ˜¯å¦åŒ…å« PDF æª”åçš„ç‰¹å¾µ (å–å‰ç¶´)
        const isDynamicMatch = extendedQuery.includes(fileName.split('_')[0]); 
        const isBaseMatch = baseKeywords.some(k => extendedQuery.includes(k) && fileName.includes(k));
        
        return isBaseMatch || isDynamicMatch;
    });
    
    return relevantFiles;
}

function callChatGPTWithRetry(messages, imageBlob = null, attachPDFs = false) {
    const apiKey = PropertiesService.getScriptProperties().getProperty("GEMINI_API_KEY");
    if (!apiKey) throw new Error("API Key Missing");

    let kbList=[]; 
    try {
        kbList = JSON.parse(PropertiesService.getScriptProperties().getProperty(CACHE_KEYS.KB_URI_LIST));
    } catch(e) {}

    const promptSheet = ss.getSheetByName(SHEET_NAMES.PROMPT);
    const configData = promptSheet.getRange("B3:C3").getValues()[0];
    let tempSetting = (typeof configData[0] === 'number') ? configData[0] : 0.6;
    const c3Prompt = configData[1] || "";

    // --- æ±ºå®šæ›è¼‰æª”æ¡ˆ ---
    let filesToAttach = [];
    if (imageBlob) {
        filesToAttach = kbList.filter(f => f.isPriority);
    } else if (attachPDFs) {
        filesToAttach = getRelevantKBFiles(messages, kbList);
    } else {
        filesToAttach = kbList.filter(f => f.isPriority); // æ¥µé€Ÿæ¨¡å¼
    }

    writeLog(`[KB Load] AttachPDFs: ${attachPDFs}, Files: ${filesToAttach.length} / ${kbList.length}`);

    // --- ä¸‰æ®µå¼é‚è¼¯æ³¨å…¥ ---
    let dynamicPrompt = `ã€Sheet C3 æŒ‡ä»¤ã€‘\n${c3Prompt}\n`;
    
    if (!attachPDFs && !imageBlob) {
        // Phase 1: æ¥µé€Ÿæ¨¡å¼
        dynamicPrompt += `\nã€âš ï¸ æ¥µé€Ÿæ¨¡å¼ - è³‡æ–™é™åˆ¶ã€‘
        ä½ ç›®å‰åªæœ‰ã€ŒQAé ã€å’Œã€ŒCLASS_RULESã€ï¼Œ**æ²’æœ‰ PDF æ‰‹å†Š**ã€‚
        è‹¥ä½¿ç”¨è€…å•æ“ä½œæ­¥é©Ÿæˆ–æ•…éšœæ’é™¤ï¼Œè€Œè³‡æ–™åº«æ²’å¯«ï¼š
        1. **åš´ç¦** çæ°æ­¥é©Ÿã€‚
        2. **å¿…é ˆ** å›ç­”ï¼šã€Œè³‡æ–™åº«è¦æ ¼é ä¸­æ²’æœ‰è¨˜è¼‰è©³ç´°æ­¥é©Ÿã€ï¼Œä¸¦åŠ ä¸Š [NEED_DOC] æš—è™Ÿã€‚`;
    } else if (attachPDFs) {
        // Phase 2 & 3: æ·±åº¦æ¨¡å¼
        dynamicPrompt += `\nã€ğŸš€ æ·±åº¦æœå°‹æ¨¡å¼ - è§£é–æ¬Šé™ã€‘
        ç³»çµ±å·²ç‚ºä½ æ›è¼‰äº† PDF æ‰‹å†Šã€‚
        1. è«‹å„ªå…ˆå¾ PDF ä¸­å°‹æ‰¾ç­”æ¡ˆã€‚
        2. **å¦‚æœé€£ PDF è£¡éƒ½æ²’æœ‰å¯«** (Phase 3)ï¼š
           é€™æ™‚ä½  **å¯ä»¥** ä½¿ç”¨é€šç”¨çŸ¥è­˜ä¾†æä¾›å»ºè­°ã€‚
           **ä½†æ˜¯ï¼** å¿…é ˆåœ¨çµå°¾åŠ ä¸Šï¼š(é€™æ˜¯æˆ‘æ ¹æ“šé€šç”¨çŸ¥è­˜çš„æ¨æ¸¬ï¼Œåƒ…ä¾›åƒè€ƒï¼Œéå®˜æ–¹ç¢ºèªè³‡è¨Š)`;
    }

    const geminiContents = [];
    if (imageBlob) {
        const imageBase64 = Utilities.base64Encode(imageBlob.getBytes());
        geminiContents.push({ 
            role: "user", 
            parts: [{ text: `ã€ä»»å‹™ã€‘åˆ†æåœ–ç‰‡:\n${c3Prompt}` }, { inline_data: { mime_type: imageBlob.getContentType(), data: imageBase64 } }] 
        });
    } else {
        let first=true;
        messages.forEach(msg => {
            if (msg.role === 'system') return; 
            const parts = [];
            if (msg.role === 'user' && first) {
                if (filesToAttach.length > 0) {
                    filesToAttach.forEach(k => parts.push({ file_data: { mime_type: k.mimeType || "text/plain", file_uri: k.uri } }));
                }
                first=false;
            }
            parts.push({ text: msg.content });
            geminiContents.push({ role: msg.role === 'assistant' ? 'model' : 'user', parts: parts });
        });
        if (first) geminiContents.push({ role: 'user', parts: [{ text: "ä½ å¥½" }] });
    }

    const payload = {
        contents: geminiContents,
        systemInstruction: imageBlob ? undefined : { parts: [{ text: dynamicPrompt }] },
        generationConfig: { maxOutputTokens: CONFIG.MAX_OUTPUT_TOKENS, temperature: tempSetting },
        safetySettings: [{category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE"}]
    };

    const url = `${CONFIG.API_ENDPOINT}/${CONFIG.MODEL_NAME}:generateContent?key=${apiKey}`;
    const start = new Date().getTime();
    
    let retryCount = 0;
    while (retryCount < 3) {
        try {
            const response = UrlFetchApp.fetch(url, { method: 'post', headers: { 'Content-Type': 'application/json' }, payload: JSON.stringify(payload), muteHttpExceptions: true });
            const endTime = new Date().getTime();
            writeLog(`[API End] ${(endTime - start)/1000}s, Code: ${response.getResponseCode()}`);
            
            const code = response.getResponseCode();
            const text = response.getContentText();
            if (code === 400 && text.includes("token")) return "âš ï¸ è³‡æ–™é‡éå¤§ï¼Œè«‹æä¾›é—œéµå­—ã€‚";
            if (code === 404) { PropertiesService.getScriptProperties().deleteProperty(CACHE_KEYS.KB_URI_LIST); throw new Error("ç´¢å¼•é‡æ•´"); }
            if (code !== 200) throw new Error(`API ${code}: ${text}`);
            
            return JSON.parse(text).candidates?.[0]?.content?.parts?.[0]?.text?.trim() || "";
        } catch (e) {
            if (e.message.includes("token")) return e.message;
            retryCount++; Utilities.sleep(1000 * Math.pow(2, retryCount));
        }
    }
    throw new Error("API é€£ç·šå¤±æ•—");
}

// ==========================================
// 4. è¨Šæ¯è™•ç† (AI-Driven Trigger)
// ==========================================

// å¼·åˆ¶åˆ—è¡¨æ’ç‰ˆ (List Formatting)
function formatListSpacing(text) {
    if (!text) return "";
    
    // ç§»é™¤å–®ä¸€é»ç·¨è™Ÿ
    if (text.includes("1.") && !text.includes("2.")) {
        text = text.replace(/^1\.\s*/gm, "");
    }
    
    let lines = text.split('\n');
    let formattedLines = [];
    for (let i = 0; i < lines.length; i++) {
        let line = lines[i].trim();
        formattedLines.push(line);
        
        // åˆ—è¡¨é …ç›®å¾ŒåŠ ç©ºè¡Œ
        if (/^\d+\./.test(line) && i < lines.length - 1 && lines[i+1].trim() !== "") {
            formattedLines.push(""); 
        }
    }
    return formattedLines.join('\n');
}

function formatForLineMobile(text) {
  if (!text) return "";
  let processed = text;
  processed = processed.replace(/\*\*(.*?)\*\*/g, '$1'); 
  processed = processed.replace(/^\*\s+/gm, 'â€¢ '); 
  processed = processed.replace(/\*/g, ''); 
  processed = processed.replace(/(\d+)\.\s+/g, '$1.');
  processed = processed.replace(/->/g, 'â†’'); 
  
  // å¼·åˆ¶åˆ†æ®µ (å¥å°¾æ›è¡Œ)
  processed = processed.replace(/([ã€‚ï¼ï¼Ÿ])\s*/g, '$1\n\n');
  // åˆ—è¡¨å‰æ›è¡Œ
  processed = processed.replace(/(\n|^)(\d+\.)/g, '\n\n$2');
  // ç§»é™¤å¤šé¤˜æ›è¡Œ
  processed = processed.replace(/\n{3,}/g, '\n\n');
  
  processed = formatListSpacing(processed);
  return processed.trim();
}

function handleMessage(userMessage, userId, replyToken, contextId) {
  try {
    if (!userMessage?.trim()) return;
    const msg = userMessage.trim();
    
    writeRecordDirectly(userId, msg, contextId, 'user', '');
    writeLog(`[HandleMsg] æ”¶åˆ°: ${msg}`); 

    const cache = CacheService.getScriptCache();
    const draftCache = cache.get(CACHE_KEYS.ENTRY_DRAFT_PREFIX + userId);
    const pendingQuery = cache.get(CACHE_KEYS.PENDING_QUERY + userId);

    // A. å»ºæª”æ¨¡å¼
    if (draftCache && !msg.startsWith('/')) {
        handleDraftModification(msg, userId, replyToken, JSON.parse(draftCache));
        return;
    }

    // B. æŒ‡ä»¤
    if (msg.startsWith('/')) {
        const cmdResult = handleCommand(msg, userId, contextId);
        replyMessage(replyToken, cmdResult);
        const isReset = (msg === '/é‡å•Ÿ' || msg === '/reboot') ? 'TRUE' : '';
        if (isReset) writeRecordDirectly(userId, msg, contextId, 'user', isReset);
        if (cmdResult) { writeRecordDirectly(userId, cmdResult, contextId, 'assistant', ''); }
        return;
    }
    
    // C. æ·±åº¦æœå°‹ç¢ºèª (åš´æ ¼é–å®š)
    const deepSearchAffirmative = msg.match(/^(1|æ·±åº¦|æŸ¥)$/i); 
    const isCancelCommand = msg.startsWith("/å–æ¶ˆ"); 

    if (pendingQuery && !isCancelCommand) {
        if (deepSearchAffirmative) {
            handleDeepSearch(pendingQuery, userId, replyToken, contextId);
            return;
        } else {
             cache.remove(CACHE_KEYS.PENDING_QUERY + userId); 
        }
    }
    
    // D. ä¸€èˆ¬å°è©±
    if (!hasRecentAnimation(userId)) { showLoadingAnimation(userId, 30); markAnimationShown(userId); }
    
    const history = getHistoryFromCacheOrSheet(contextId);
    const userMsgObj = { role: "user", content: msg };
    
    // [ç›´é€šè»Š] å¼·åˆ¶æ·±åº¦æœå°‹
    const forceDeep = isDirectDeepSearch(msg);
    if (forceDeep) writeLog("[Direct] è§¸ç™¼ç›´é€šè»Š");

    try {
        const rawResponse = callChatGPTWithRetry([...history, userMsgObj], null, forceDeep); 
        if (rawResponse) {
          let finalText = formatForLineMobile(rawResponse);
          
          // AI è‡ªè¦ºè§¸ç™¼æª¢æŸ¥ (åƒ…éç›´é€šè»Šæ¨¡å¼)
          let showFollowUp = false;
          if (!forceDeep && finalText.includes("[NEED_DOC]")) {
              finalText = finalText.replace(/\[NEED_DOC\]/g, "").trim();
              showFollowUp = true;
          }
          
          let replyText = finalText;
          if (showFollowUp) {
               replyText += "\n\n" + generateFollowUpPrompt();
          }

          replyMessage(replyToken, replyText);
          
          if (!forceDeep) cache.put(CACHE_KEYS.PENDING_QUERY + userId, msg, 120); 
          
          writeRecordDirectly(userId, replyText, contextId, 'assistant', '');
          writeLog(`[AI Reply] ${finalText}`); 
          
          updateHistorySheetAndCache(contextId, history, userMsgObj, { role: 'assistant', content: finalText });
        } else {
            writeLog(`[Error] AI å›å‚³ç‚ºç©º`);
            replyMessage(replyToken, "ç³»çµ±å¿™ç¢Œä¸­ (AI Empty)");
        }
    } catch (apiErr) {
        replyMessage(replyToken, `ç³»çµ±éŒ¯èª¤ï¼š${apiErr.message}`);
        writeLog(`[Handle API Error] ${apiErr.message}`);
    }
  } catch (error) { writeLog("[Fatal] " + error); }
}

// ç›´é€šè»Šåˆ¤æ–·
function isDirectDeepSearch(msg) {
    const text = msg.toUpperCase();
    // é€™è£¡å¯ä»¥æ”¾ä¸€äº›çµ•å°éœ€è¦çœ‹æ‰‹å†Šçš„é—œéµå­—
    const strongKeywords = ["G90XF", "G95SC", "G80SD", "G81SF"];
    return strongKeywords.some(k => text.includes(k));
}

function handleDeepSearch(originalQuery, userId, replyToken, contextId) {
    const cache = CacheService.getScriptCache();
    cache.remove(CACHE_KEYS.PENDING_QUERY + userId); 

    if (!hasRecentAnimation(userId)) { showLoadingAnimation(userId, 30); markAnimationShown(userId); }
    Utilities.sleep(500); 

    const history = getHistoryFromCacheOrSheet(contextId);
    const userMsgObj = { role: "user", content: originalQuery }; 

    try {
        // æ·±åº¦å‘¼å«
        const rawResponse = callChatGPTWithRetry([...history, userMsgObj], null, true); 
        
        if (rawResponse) {
            let finalText = formatForLineMobile(rawResponse);
            replyMessage(replyToken, `ğŸš€ æ·±åº¦æœå°‹çµæœï¼š\n\n${finalText}`);
            
            writeRecordDirectly(userId, `[æ·±åº¦] ${originalQuery}`, contextId, 'user', '');
            writeRecordDirectly(userId, finalText, contextId, 'assistant', 'DEEP_SEARCH');
            writeLog(`[Deep Reply] ${finalText}`);
            updateHistorySheetAndCache(contextId, history, { role: 'user', content: originalQuery }, { role: 'assistant', content: `(æ·±åº¦æœå°‹) ${finalText}` });
        }
    } catch (e) { 
        replyMessage(replyToken, "æ·±åº¦æœå°‹å¤±æ•—"); 
        writeLog("[DeepSearch Error] " + e); 
    }
}

// æç¤ºèªç”Ÿæˆå™¨
function generateFollowUpPrompt() {
    return "ğŸ’¡ é€™éœ€è¦æŸ¥é–±è©³ç´°æ‰‹å†Šæ‰èƒ½è§£æ±ºã€‚ç¹¼çºŒæ·±å…¥æœå°‹è«‹è¼¸å…¥ã€Œ1ã€ï¼Œå°‡æœƒç”¨æ›´å¤šæ™‚é–“æœå°‹ç›¸é—œå‹è™Ÿçš„ç”¢å“ä½¿ç”¨æ‰‹å†Šã€‚";
}

function handleImageMessage(msgId, userId, replyToken, contextId) {
  try {
    writeLog(`[Image] æ”¶åˆ°åœ–ç‰‡ MsgId: ${msgId}`);
    writeRecordDirectly(userId, "[å‚³åœ–]", contextId, 'user', '');

    if (!hasRecentAnimation(userId)) { showLoadingAnimation(userId, 45); markAnimationShown(userId); }

    const token = PropertiesService.getScriptProperties().getProperty("TOKEN");
    const blob = UrlFetchApp.fetch(`https://api-data.line.me/v2/bot/message/${msgId}/content`, { headers: { "Authorization": "Bearer " + token } }).getBlob();

    const analysis = callChatGPTWithRetry(null, blob);
    const final = formatForLineMobile(analysis);
    replyMessage(replyToken, final);
    
    writeRecordDirectly(userId, final, contextId, 'assistant', '');
    
    const history = getHistoryFromCacheOrSheet(contextId);
    updateHistorySheetAndCache(contextId, history, 
        { role: 'user', content: "[ä½¿ç”¨è€…å‚³é€äº†ä¸€å¼µåœ–ç‰‡]" }, 
        { role: 'assistant', content: `(é‡å°åœ–ç‰‡çš„åˆ†æçµæœ) ${final}` }
    );
  } catch (e) {
    writeLog(`[Image Error] ${e.message}`);
    replyMessage(replyToken, "æŠ±æ­‰ï¼Œæˆ‘çœ‹åœ–ç‰‡å‡ºäº†é»å•é¡Œï¼Œè«‹ç¨å¾Œå†è©¦ ğŸ”§");
  }
}

// ==========================================
// 5. å»ºæª”èˆ‡æŒ‡ä»¤æµç¨‹
// ==========================================

function handleCommand(c, u, cid) {
  const cmd = c.trim();
  const draftKey = CACHE_KEYS.ENTRY_DRAFT_PREFIX + u;
  
  if (cmd === "/é‡å•Ÿ" || cmd === "/reboot") {
      clearHistorySheetAndCache(cid); 
      const resultMsg = syncGeminiKnowledgeBase(); 
      return `âœ“ é‡å•Ÿå®Œæˆ (å°è©±å·²é‡ç½®)\n${resultMsg}`;
  }

  if (cmd === "/å–æ¶ˆ") {
      CacheService.getScriptCache().remove(draftKey);
      CacheService.getScriptCache().remove(CACHE_KEYS.PENDING_QUERY + u); 
      return "âŒ å·²å–æ¶ˆå»ºæª”ï¼Œå›åˆ°ä¸€èˆ¬å°è©±æ¨¡å¼ã€‚";
  }
  
  if (cmd.startsWith("/è¨˜éŒ„") || cmd.startsWith("/ç´€éŒ„")) {
      const pendingDraft = CacheService.getScriptCache().get(draftKey);
      const inputContent = cmd.replace(/^\/ç´€éŒ„\s*/i, "").replace(/^\/è¨˜éŒ„\s*/i, "").trim();

      if (pendingDraft && inputContent === "") {
          return saveDraftToSheet(JSON.parse(pendingDraft));
      }

      if (inputContent !== "") {
          return startNewEntryDraft(inputContent, u);
      }

      return handleAutoQA(u, cid);
  }

  return `âŒ æœªçŸ¥æŒ‡ä»¤\n\nã€æŒ‡ä»¤åˆ—è¡¨ã€‘\n/é‡å•Ÿ -> é‡ç½®å°è©±+æ›´æ–°\n/ç´€éŒ„ <å…§å®¹> -> é–‹å§‹å»ºæª”\n/ç´€éŒ„ -> å­˜æª”/æ•´ç†QA\n/å–æ¶ˆ -> é€€å‡ºå»ºæª”`;
}

function startNewEntryDraft(content, userId) {
    try {
        const draft = callGeminiToDraft(content, "initial", null);
        CacheService.getScriptCache().put(CACHE_KEYS.ENTRY_DRAFT_PREFIX + userId, JSON.stringify(draft), CONFIG.DRAFT_TTL_SEC);
        
        const alertMsg = "âš ï¸ **å·²é€²å…¥å»ºæª”æ¨¡å¼ã€‚** æ¥ä¸‹ä¾†çš„å°è©±å°‡è¦–ç‚ºå°è‰ç¨¿çš„ä¿®æ”¹æŒ‡ä»¤ï¼Œç›´åˆ°æ‚¨è¼¸å…¥ /ç´€éŒ„ å­˜æª”ç‚ºæ­¢ã€‚";
        
        return alertMsg + "\n\n" + generatePreviewMsg(draft);
    } catch (e) { return `âŒ åˆ†æå¤±æ•—ï¼š${e.message}`; }
}

function handleDraftModification(feedback, userId, replyToken, currentDraft) {
    try {
        const newDraft = callGeminiToDraft(feedback, "modify", currentDraft);
        CacheService.getScriptCache().put(CACHE_KEYS.ENTRY_DRAFT_PREFIX + userId, JSON.stringify(newDraft), CONFIG.DRAFT_TTL_SEC);
        replyMessage(replyToken, `ğŸ”„ å·²ä¿®æ­£è‰ç¨¿ï¼š\n\n${generatePreviewMsg(newDraft)}`);
    } catch (e) { replyMessage(replyToken, "âŒ ä¿®æ”¹å¤±æ•—"); }
}

function cleanJson(text) {
    try {
        let cleaned = text.replace(/```json/g, "").replace(/```/g, "").trim();
        return JSON.parse(cleaned);
    } catch (e) { throw new Error("AI æ ¼å¼éŒ¯èª¤"); }
}

function callGeminiToDraft(input, mode, prevDraft) {
    const apiKey = PropertiesService.getScriptProperties().getProperty("GEMINI_API_KEY");
    let prompt = "";

    if (mode === "initial") {
        prompt = `
        ä½ æ˜¯ä¸€å€‹å°ˆæ¥­çš„è³‡æ–™åº«å»ºæª”å°ˆå“¡ã€‚è«‹è™•ç†ä½¿ç”¨è€…è¼¸å…¥çš„ã€Œéçµæ§‹åŒ–ç¶²é æ–‡æœ¬ã€ï¼Œä¸¦å°‡å…¶è½‰æ›ç‚ºçµæ§‹åŒ–çš„ JSONã€‚
        ã€æ ¸å¿ƒä»»å‹™ï¼šä¸»é«”é–å®šã€‘
        1. é—œéµå­—æª¢æ ¸ï¼šä¸»è§’ç”¢å“å¿…é ˆåŒ…å«ã€Œä¸‰æ˜Ÿ/SAMSUNGã€æˆ–å‹è™Ÿä»¥ã€ŒS/LSã€é–‹é ­ä¸”ç·Šæ¥å…©ä½æ•¸å­—(24-57)ã€‚
        2. å¯†åº¦æƒæï¼šæ‰¾å‡ºæè¿°æœ€å®Œæ•´çš„ä¸»è§’ç”¢å“ï¼Œå¿½ç•¥å…¶ä»–ç„¡é—œå•†å“(è²“ç½é ­ã€åŠ åƒ¹è³¼)ã€‚
        ã€åˆ¤æ–·èˆ‡æ ¼å¼ã€‘
        1. å…§å®¹ç‚ºã€Œè¦æ ¼è¡¨/ç”¢å“ä»‹ç´¹ã€ -> type="rule"ã€‚
        2. å…§å®¹ç‚ºã€ŒQA/æ•…éšœæ’é™¤ã€ -> type="qa"ã€‚
        3. æ‘˜è¦èªªæ˜èªæ°£ç‚ºã€Œæ‡‚é›»è…¦çš„æœ‹å‹ã€ã€‚
        4. å›å‚³ JSON:
           - QA: {"type":"qa", "q":"ç°¡æ½”å•é¡Œ", "a":"å®Œæ•´è§£ç­”"}
           - Rule: {"type":"rule", "key":"é—œéµå­—(å‹è™Ÿ)", "def":"å®šç¾©(è¦æ ¼ç°¡è¿°)", "desc":"è©³ç´°èªªæ˜"}
        `;
    } else {
        prompt = `ä¿®æ”¹è‰ç¨¿ JSONã€‚ç›®å‰ JSON: ${JSON.stringify(prevDraft)}ã€‚ä¿®æ”¹æŒ‡ä»¤: "${input}"ã€‚å›å‚³ä¿®æ­£å¾Œçš„ JSONã€‚`;
    }

    const payload = {
        contents: [{ role: "user", parts: [{ text: prompt + `\n\nã€è¼¸å…¥å…§å®¹ã€‘: ${mode==='initial' ? input : ''}` }] }],
        generationConfig: { responseMimeType: "application/json" }
    };
    
    const res = UrlFetchApp.fetch(`${CONFIG.API_ENDPOINT}/${CONFIG.MODEL_NAME}:generateContent?key=${apiKey}`, { method: 'post', headers: {'Content-Type':'application/json'}, payload: JSON.stringify(payload), muteHttpExceptions: true });
    const rawText = JSON.parse(res.getContentText()).candidates[0].content.parts[0].text;
    
    return cleanJson(rawText);
}

function generatePreviewMsg(draft) {
    let msg = "";
    const today = new Date().toLocaleDateString();
    
    if (draft.type === "qa") {
        msg = `ã€æ¨¡å¼ï¼šQA (å•ç­”)ã€‘\nQï¼š${draft.q}\nAï¼š${draft.a}\n\nğŸ’¡ å­˜æª”é è¦½ (å–®æ¬„)ï¼š\n${today}, ä¸€ã€ç”¢å“è«®è©¢, 00.AIç´€éŒ„, ${draft.q}, ${draft.a}, Manual`;
    } else {
        msg = `ã€æ¨¡å¼ï¼šRule (å®šç¾©)ã€‘\né—œéµå­—ï¼š${draft.key}\nå®šç¾©ï¼š${draft.def}\nèªªæ˜ï¼š${draft.desc}\n\nğŸ’¡ å­˜æª”é è¦½ (å–®æ¬„)ï¼š\n${draft.key}, ${draft.def}, Manual, ${draft.desc}`;
    }

    msg += `\n\nğŸ‘‰ ç¢ºèª -> è¼¸å…¥ "/ç´€éŒ„"\nğŸ‘‰ ä¿®æ”¹ -> ç›´æ¥å›è¦†æ–‡å­—\nğŸ‘‰ æ”¾æ£„ -> è¼¸å…¥ "/å–æ¶ˆ"`;
    draft.userId = "USER_ID_PLACEHOLDER"; 
    return msg;
}

function saveDraftToSheet(draft) {
    if (draft.type === 'error') return "âŒ ç„¡æ•ˆå…§å®¹ï¼Œç„¡æ³•å­˜æª”ã€‚";
    
    let success = false;
    let sheetType = "";
    
    if (draft.type === "qa") {
        success = writeQA('ä¸€ã€ç”¢å“è«®è©¢', '00.AIç´€éŒ„', draft.q, draft.a, 'ä¾†æº:Manual');
        sheetType = "QA";
    } else if (draft.type === "rule") {
        success = writeRule(draft.key, draft.def, 'Manual', draft.desc);
        sheetType = "CLASS_RULES";
    }

    if (success) {
        CacheService.getScriptCache().remove(CACHE_KEYS.ENTRY_DRAFT_PREFIX + draft.userId); 
        syncGeminiKnowledgeBase();
        return `âœ… å·²å¯«å…¥ [${sheetType}] (å–®æ¬„) ä¸¦æ›´æ–°çŸ¥è­˜åº«ï¼`;
    }
    return "âŒ å¯«å…¥å¤±æ•—";
}

function handleAutoQA(u, cid) {
    const history = getHistoryFromCacheOrSheet(cid);
    if (history.length < 2) return "âŒ å°è©±ä¸è¶³";
    try {
        const contentText = "æ•´ç†æ­·å²å°è©±ç‚º QAï¼š\n" + history.slice(-6).map(m=>`${m.role}:${m.content}`).join("\n");
        const draft = callGeminiToDraft(contentText, "initial", null); 
        
        if (draft.q && draft.a) {
            const cleanQ = formatForLineMobile(draft.q);
            const cleanA = formatForLineMobile(draft.a);
            writeQA('ä¸€ã€ç”¢å“è«®è©¢', '00.AIç´€éŒ„', cleanQ, cleanA, 'ä¾†æº:Auto');
            syncGeminiKnowledgeBase();
            return `âœ“ [QA] å·²å­˜æª”ï¼š\nQ: ${cleanQ.substring(0,15)}...`;
        }
        return "âŒ å­˜æª”å¤±æ•—";
    } catch (e) { return "âŒ æ•´ç†å¤±æ•—"; }
}

// ==========================================
// 6. è³‡æ–™å¯«å…¥èˆ‡å·¥å…·å‡½å¼ (å…¨å±•é–‹)
// ==========================================

function sanitizeForSheet(text) {
  if (!text) return "";
  let s = text.toString();
  s = s.replace(/[\r\n]+/g, " "); 
  s = s.replace(/,/g, "ï¼Œ");
  s = s.replace(/:/g, "ï¼š");
  return s.trim();
}

function writeQA(l,s,p,a,n) {
  const lock = LockService.getScriptLock();
  try { 
    lock.waitLock(10000);
    const sheet = ss.getSheetByName(SHEET_NAMES.QA);
    if (!sheet) return false;
    const cleanP = sanitizeForSheet(p);
    const cleanA = sanitizeForSheet(a);
    const cleanN = sanitizeForSheet(n);
    sheet.appendRow([[new Date().toLocaleDateString(),l,s,cleanP,cleanA,cleanN].join(", ")]);
    SpreadsheetApp.flush();
    return true;
  } catch (e) { 
      writeLog("[WriteQA Error] " + e);
      return false; 
  } finally { 
      try { lock.releaseLock(); } catch (e) {} 
  }
}

function writeRule(k,d,u,desc) {
  const lock = LockService.getScriptLock();
  try { 
    lock.waitLock(10000);
    const sheet = ss.getSheetByName(SHEET_NAMES.CLASS_RULES);
    if (!sheet) return false;
    const cleanK = sanitizeForSheet(k);
    const cleanD = sanitizeForSheet(d);
    const cleanDesc = sanitizeForSheet(desc);
    sheet.appendRow([[cleanK,cleanD,u,cleanDesc].join(", ")]);
    SpreadsheetApp.flush();
    return true;
  } catch (e) { 
      writeLog("[WriteRule Error] " + e);
      return false; 
  } finally { 
      try { lock.releaseLock(); } catch (e) {} 
  }
}

function writeRecordDirectly(u,t,c,r,f) {
  try { 
    ss.getSheetByName(SHEET_NAMES.RECORDS).appendRow([new Date(), c, u, formatForLineMobile(t), r, f]); 
    SpreadsheetApp.flush(); 
  } catch(e) {
    console.error("Record Error: " + e.message);
  }
}

function writeLog(msg) {
  if(ss) {
      try { 
          // ç§»é™¤æ›è¡Œï¼Œç¢ºä¿ Log å–®è¡Œ
          const cleanMsg = msg.replace(/[\r\n]+/g, " ");
          ss.getSheetByName(SHEET_NAMES.LOG).appendRow([new Date(), cleanMsg]); 
          SpreadsheetApp.flush(); 
      } catch(e){} 
  }
  console.log(msg);
}

function getHistoryFromCacheOrSheet(cid) {
  const c = CacheService.getScriptCache();
  const k = `${CACHE_KEYS.HISTORY_PREFIX}${cid}`;
  const v = c.get(k);
  if (v) {
      try { return JSON.parse(v); } catch(e) {}
  }
  try {
    const s = ss.getSheetByName(SHEET_NAMES.LAST_CONVERSATION);
    const f = s.getRange("A:A").createTextFinder(cid).matchEntireCell(true).findNext();
    if (f) {
        return JSON.parse(s.getRange(f.getRow(), 2).getValue());
    }
  } catch(e) {}
  return [];
}

function updateHistorySheetAndCache(cid, prev, uMsg, aMsg) {
  try {
    let base = Array.isArray(prev) ? prev.slice() : [];
    if (base.length % 2 !== 0) {
        base.shift();
    }
    const newHist = [...base, uMsg, aMsg].slice(-(CONFIG.HISTORY_PAIR_LIMIT * 2));
    const json = JSON.stringify(newHist);
    const s = ss.getSheetByName(SHEET_NAMES.LAST_CONVERSATION);
    const f = s.getRange("A:A").createTextFinder(cid).matchEntireCell(true).findNext();
    
    if (f) {
        s.getRange(f.getRow(), 2).setValue(json);
    } else {
        s.appendRow([cid, json]);
    }
    CacheService.getScriptCache().put(`${CACHE_KEYS.HISTORY_PREFIX}${cid}`, json, CONFIG.CACHE_TTL_SEC);
  } catch (e) {}
}

function clearHistorySheetAndCache(cid) {
  try {
    const s = ss.getSheetByName(SHEET_NAMES.LAST_CONVERSATION);
    const f = s.getRange("A:A").createTextFinder(cid).matchEntireCell(true).findNext();
    if (f) {
        s.getRange(f.getRow(), 2).clearContent();
    }
    CacheService.getScriptCache().remove(`${CACHE_KEYS.HISTORY_PREFIX}${cid}`);
  } catch (e) {}
}

// ========== 7. LINE Webhook å…¥å£ ==========

function doPost(e) {
  try {
    const json = JSON.parse(e?.postData?.contents || '{}');
    json.events?.forEach(event => {
      if (event.type === 'message') {
        const eventId = event.webhookEventId;
        if (isDuplicateEvent(eventId)) return;
        
        const isGroup = event.source.type === 'group' || event.source.type === 'room';
        let contextId = isGroup ? event.source.groupId : event.source.userId;
        let userId = event.source.userId;
        let replyToken = event.replyToken;

        if (isGroup) {
            if (event.message.type === 'text') {
                const botUserId = getBotUserId();
                const mentions = event.message.mention?.mentionees || [];
                if (!mentions.some(m => m.userId === botUserId)) return;
                let cleanedText = event.message.text;
                mentions.forEach(m => { 
                    if (m.userId === botUserId) {
                        cleanedText = cleanedText.replace(cleanedText.substring(m.index, m.index + m.length), '').trim(); 
                    }
                });
                if (!cleanedText) { replyMessage(replyToken, "æœ‰äº‹å—ï¼Ÿ"); return; }
                handleMessage(cleanedText, userId, replyToken, contextId);
            } else if (event.message.type === 'image') {
                if (userId === CONFIG.VIP_IMAGE_USER) {
                    handleImageMessage(event.message.id, userId, replyToken, contextId);
                }
            }
        } else {
            if (event.message.type === 'text') {
                handleMessage(event.message.text, userId, replyToken, contextId);
            } else if (event.message.type === 'image') {
                handleImageMessage(event.message.id, userId, replyToken, contextId);
            }
        }
      }
    });
    return ContentService.createTextOutput(JSON.stringify({ status: "ok" })).setMimeType(ContentService.MimeType.JSON);
  } catch (e) { return ContentService.createTextOutput(JSON.stringify({ status: "error" })).setMimeType(ContentService.MimeType.JSON); }
}

// ========== 8. è¼”åŠ©å·¥å…· (Utils) ==========

function replyMessage(tk, txt) {
  try {
    UrlFetchApp.fetch("https://api.line.me/v2/bot/message/reply", {
      method: "post",
      headers: { "Content-Type": "application/json", "Authorization": "Bearer " + PropertiesService.getScriptProperties().getProperty("TOKEN") },
      payload: JSON.stringify({ replyToken: tk, messages: [{ type: "text", text: txt.substring(0, 4000) }] }),
      muteHttpExceptions: true
    });
  } catch (e) {
      writeLog("[Reply Error] " + e);
  }
}

function showLoadingAnimation(uid, sec) {
  try {
    UrlFetchApp.fetch("https://api.line.me/v2/bot/chat/loading/start", {
      method: "post",
      headers: { "Authorization": "Bearer " + PropertiesService.getScriptProperties().getProperty("TOKEN"), "Content-Type": "application/json" },
      payload: JSON.stringify({ chatId: uid, loadingSeconds: sec }),
      muteHttpExceptions: true
    });
  } catch (e) {}
}

function getBotUserId() {
  let id = PropertiesService.getScriptProperties().getProperty("BOT_USER_ID");
  if (!id) {
    try {
      const res = UrlFetchApp.fetch("https://api.line.me/v2/bot/info", { headers: { "Authorization": "Bearer " + PropertiesService.getScriptProperties().getProperty("TOKEN") } });
      if (res.getResponseCode() === 200) { 
          id = JSON.parse(res.getContentText()).userId; 
          PropertiesService.getScriptProperties().setProperty("BOT_USER_ID", id); 
      }
    } catch (e) {}
  }
  return id;
}

function isDuplicateEvent(id) {
  const c = CacheService.getScriptCache();
  if(c.get(id)) return true;
  c.put(id,'1',60);
  return false;
}

function hasRecentAnimation(id) { 
    return CacheService.getScriptCache().get(`anim_${id}`) != null; 
}

function markAnimationShown(id) { 
    CacheService.getScriptCache().put(`anim_${id}`, '1', 20); 
}

function runInitializeAndSync() { 
    Object.values(SHEET_NAMES).forEach(name => { 
        if (!ss.getSheetByName(name)) {
            ss.insertSheet(name); 
        }
    }); 
    syncGeminiKnowledgeBase(); 
}